# -*- coding: utf-8 -*-
"""Telco - Data Preprocessing_Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sch6reCWBrx4FPX7qItXdPLfNxSfj6DW

**Prepare all required libraries**
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

""" **Import Dataset**"""

#import dataset
url = 'https://raw.githubusercontent.com/dimsdika12/data-analytics-projects/main/Telco_Data%20Preprocessing/dataset/telco.csv'
df_load = pd.read_csv(url)

# Display the number of rows and columns
print(df_load.shape)

# Display the top 5 rows of the dataset
print(df_load.head())

# Count the number of unique IDs
print(df_load["customerID"].nunique())

"""# **Look for a valid customer ID (Phone number)**

**Filtering Customer ID Numbers in Certain Formats**
- Character length is 11-12.
- Consists of numbers only, no characters other than numbers are allowed
- Starting with the number 45, the first 2 digits.
"""

df_load['valid_id'] = df_load['customerID'].astype(str).str.match(r'(45\d{9,10})')
df_load = (df_load[df_load['valid_id'] == True]).drop('valid_id', axis=1)
print('The results of the number of filtered CustomerIDs are',df_load['customerID'].count())

"""**Filtering Duplicate Customer ID Numbers**

Make sure there are no duplicate customer IDs. ID duplication often occurs for two main reasons:

- Duplication is caused by filling in data more than once with the same values for each column.
- Duplication is caused by data filling in at different data collection periods.
"""

df_load.duplicated('customerID').sum()

# Drop Duplicate Rows
df_load.drop_duplicates()
# Drop duplicate ID sorted by Periode
df_load = df_load.sort_values('UpdatedAt', ascending=False).drop_duplicates('customerID')
print('The results of the number of CustomerIDs that have been deduplicated (distinct) are',df_load['customerID'].count())

df_load.duplicated().sum()

"""# **Handling Missing Values**"""

df_load.isnull().sum()

"""Missing values are found in the column `Churn`, `tenure`, `MonthlyCharges` & `TotalCharges`.

Handling Missing Values by Removing Rows
- remove missing value rows in column `churn`
"""

print("Total missing values data from the Churn column",df_load['Churn'].isnull().sum())
# Dropping all Rows with spesific column (churn)
df_load.dropna(subset=['Churn'], inplace=True)
print("Total Rows and Columns after deleting Missing Values data are",df_load.shape)

"""Handling Missing Values by Filling in Certain Values
- fill missing value column `tenure` with 11
- fill others column missing `value `with median
"""

print('Status Missing Values :',df_load.isnull().values.any())
print('\nThe number of Missing Values for each column is:')
print(df_load.isnull().sum().sort_values(ascending=False))

#handling missing values Tenure fill with 11
df_load['tenure'].fillna(11,inplace=True)

#Loop
#Handling missing values num vars (except Tenure)
for col_name in  list(['MonthlyCharges','TotalCharges']):
    #write your command here
	median = df_load[col_name].median()
	df_load[col_name].fillna(median, inplace=True)

print('\nThe number of Missing Values after imputing the data is:')
print(df_load.isnull().sum().sort_values(ascending=False))

"""# **Detecting outliers**"""

# before delete outliers
# Display a boxplot for the 'tenure' column
plt.figure()
sns.boxplot(x=df_load['tenure'])
plt.show()

# Display a boxplot for the 'MonthlyCharges' column
plt.figure()
sns.boxplot(x=df_load['MonthlyCharges'])
plt.show()

# Display a boxplot for the 'TotalCharges' column
plt.figure()
sns.boxplot(x=df_load['TotalCharges'])
plt.show()

# Handling with IQR
Q1 = (df_load[['tenure','MonthlyCharges','TotalCharges']]).quantile(0.25)
Q3 = (df_load[['tenure','MonthlyCharges','TotalCharges']]).quantile(0.75)

IQR = Q3 - Q1
maximum  = Q3 + (1.5*IQR)
print('The maximum value of each variable is: ')
print(maximum)
minimum = Q1 - (1.5*IQR)
print('\nThe minimum value of each variable is: ')
print(minimum)

more_than     = (df_load > maximum)
lower_than    = (df_load < minimum)
df_load       = df_load.mask(more_than, maximum, axis=1)
df_load       = df_load.mask(lower_than, minimum, axis=1)

print('\nData distribution after handling outliers: ')
print(df_load[['tenure','MonthlyCharges','TotalCharges']].describe())

"""Plotting boxplots to check for outliers; observing whether there are any outliers present"""

# after delete outliers
# Display a boxplot for the 'tenure' column
plt.figure()
sns.boxplot(x=df_load['tenure'])
plt.show()

# Display a boxplot for the 'MonthlyCharges' column
plt.figure()
sns.boxplot(x=df_load['MonthlyCharges'])
plt.show()

# Display a boxplot for the 'TotalCharges' column
plt.figure()
sns.boxplot(x=df_load['TotalCharges'])
plt.show()

"""# **Standardizing the Values of Variables**

cek value_counts each columns to counts the number of occurrences of each unique value in a column
"""

for col_name in list(['gender','SeniorCitizen','Partner','Dependents','PhoneService','MultipleLines','InternetService',
                      'OnlineSecurity','OnlineBackup','DeviceProtection','TechSupport','StreamingTV','StreamingMovies',
                      'Contract','PaperlessBilling','PaymentMethod','Churn']):
	#write your command here
	print('\nUnique Values Count Before Standardized Variable',col_name)
	print(df_load[col_name].value_counts())

"""After inspection, it was determined that three columns (gender, Dependents, Churn) contain several non-standard variables. Those variables are:

- `Gender` (Female, Male, Woman, Man), which can be unified to (Female, Male) as they carry identical meanings.
- `Dependents` (Yes, No, Yes), which can be standardized to (Yes, No) since they convey the same intent.
- `Churn` (Yes, No, Churn), which can be standardized to (Yes, No) as it signifies the same concept.
"""

df_load = df_load.replace(['Wanita','Laki-Laki','Churn','Iya'],['Female','Male','Yes','Yes'])

#Loop
for col_name in (['gender','Dependents','Churn']):
	#write your command here
	print('\nUnique Values Count After Standardized Variable',col_name)
	print(df_load[col_name].value_counts())